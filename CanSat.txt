//yaw角の反映と挙動確認
// MPU9265 + AE-GPS + LIS3MDL + LPS + サーボ制御 + 姿勢角(Madgwick)
// 目的: パラフォイルを制御し、目標地点に誘導
// 修正点: GPSが未取得の時はサーボをニュートラルに固定しつつ、他センサの値は表示
#include <Wire.h>
#include <math.h>
#include <Servo.h>
#include <LIS3MDL.h>
#include <LPS.h>
#include <TinyGPS++.h>
#include <SoftwareSerial.h>
#include "MadgwickAHRS.h"

// --------- GPS設定 (AE-GPS: UART接続) ----------
TinyGPSPlus gps;
SoftwareSerial gpsSerial(4, 3); // GPS TX → D4, GPS RX → D3

// --------- サーボ ----------
Servo myservo, myservo2; //右、左

// --------- 磁気センサ ----------
LIS3MDL LIS;

// --------- 気圧センサ ----------
LPS ps;

// --------- MPU9265 I2Cアドレス ----------
#define MPU9250_ADDR 0x68

// --------- センサ値格納用 ----------
float AcX, AcY, AcZ;
float GyX, GyY, GyZ;
float MagX, MagY, MagZ;

// --------- 姿勢推定フィルタ ----------
Madgwick filter;
float roll, pitch, yaw;

// --------- 制御用変数 ----------
double gps_theta = 0, mag_theta = 0, theta = 0, distance = 0;
float hight_b = 0, hight_a = 0;
float dlat = 0, dlng = 0;
float outer = 0;
unsigned long prevMillis = 0;
const unsigned long interval = 1000; // 1秒ごとに出力
String control_log = "no action";
unsigned long nexttime = 0;

// 目標地点
double lat1 = 35.139700; //目標緯度(仮)
double long1 = 136.966293; //目標経度(仮)

// --------- MPU9265初期化 ----------
void initMPU9265() {
  Wire.beginTransmission(MPU9250_ADDR);
  Wire.write(0x6B); // PWR_MGMT_1
  Wire.write(0x00); // 起動
  Wire.endTransmission(true);
}

// --------- MPU9265読み取り ----------
void readMPU9265() {
  Wire.beginTransmission(MPU9250_ADDR);
  Wire.write(0x3B);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU9250_ADDR, 14, true);

  int16_t rawAcX = (Wire.read() << 8) | Wire.read();
  int16_t rawAcY = (Wire.read() << 8) | Wire.read();
  int16_t rawAcZ = (Wire.read() << 8) | Wire.read();
  Wire.read(); Wire.read(); // 温度は未使用
  int16_t rawGyX = (Wire.read() << 8) | Wire.read();
  int16_t rawGyY = (Wire.read() << 8) | Wire.read();
  int16_t rawGyZ = (Wire.read() << 8) | Wire.read();

  // ±2g, ±250dps換算
  AcX = rawAcX / 16384.0;
  AcY = rawAcY / 16384.0;
  AcZ = rawAcZ / 16384.0;

  GyX = rawGyX / 131.0;
  GyY = rawGyY / 131.0;
  GyZ = rawGyZ / 131.0;
}

// --------- 初期化処理 ----------
void setup() {
  Serial.begin(115200);
  Wire.begin();
  gpsSerial.begin(9600);

  myservo.attach(9);
  myservo2.attach(10);

  // 磁気センサ
  if (!LIS.init()) {
    Serial.println("Failed to detect magnetometer!");
    while (1);
  }
  LIS.enableDefault();

  // 気圧センサ
  if (!ps.init()) {
    Serial.println("Failed to detect pressure sensor!");
    while (1);
  }
  ps.enableDefault();

  // MPU9265
  initMPU9265();

  // Madgwickフィルタ初期化
  filter.begin(100); // 推定周波数 100Hz

  myservo.write(140);
  myservo2.write(140);

  Serial.println("===== システム起動 =====");
}

// --------- メインループ ----------
void loop() {
  LIS.read();
  // GPSデータ受信
  while (gpsSerial.available() > 0) {
    gps.encode(gpsSerial.read());
  }

  unsigned long currentMillis = millis();
  if (currentMillis - prevMillis >= interval) {
    prevMillis = currentMillis;
    displayInfo();
  }
  while(millis() < nexttime) {}
  nexttime = millis() + 100;
}

// --------- 情報出力 ----------
void displayInfo() {
  control_log = "no action"; // デフォルト

  Serial.println("ーーーーーーーーーーーーーーーーーーーー");

  // ---- GPS位置 ----
  double lat_target = lat1;
  double long_target = long1;

  if (gps.location.isValid()) {
    double gps_lat = gps.location.lat();
    double gps_lng = gps.location.lng();

    Serial.print("目標緯度: "); Serial.println(lat_target, 6);
    Serial.print("目標経度: "); Serial.println(long_target, 6);
    Serial.print("現在緯度: "); Serial.println(gps_lat, 6);
    Serial.print("現在経度: "); Serial.println(gps_lng, 6);

    double distance_y = abs((gps_lat - lat_target)* 111320);
    double distance_x = abs((gps_lng - long_target)* 111320*cos(lat_target*(PI/180.0)));
    distance = sqrt(pow(distance_y, 2) + pow(distance_x, 2));
    Serial.print("直線距離: "); Serial.println(distance, 6);

    static double prevLat = gps_lat;
    static double prevLng = gps_lng;

    double headingToTarget = gps.courseTo(gps_lat, gps_lng, lat_target, long_target);
    double headingMoved    = gps.courseTo(prevLat, prevLng, gps_lat, gps_lng);

    theta = headingToTarget - headingMoved;
    if (theta > 180) theta -= 360;
    if (theta < -180) theta += 360;
    
    Serial.print("headingToTarget[deg]: "); Serial.println(headingToTarget, 1);
    Serial.print("headingMoved[deg]:    "); Serial.println(headingMoved, 1);


    //outer = theta; // 今回は単純化して外側判定用に代入
    theta = fabs(theta); // 角度は正の値に変換


    Serial.print("theta_signed[deg]: "); Serial.println(outer, 1);  // -180〜+180（左右判定に使用）


    prevLat = gps_lat; // 次回比較用に保存
    prevLng = gps_lng;


    dlat = (lat_target-gps_lat)*(180/PI);
    dlng = (long_target-gps_lng)*(180/PI);
  }
  // ---- 気圧センサ ----
  float pressure = ps.readPressureMillibars();
  float temperature = ps.readTemperatureC();
  double P = pow(1013.25/pressure, 1/5.257)-1;
  double T = temperature + 273.15;
  hight_a = ((P * T)/0.0065)-34.8;
  Serial.print("高度: "); Serial.println(hight_a);

  // ---- MPU9265 ----
  readMPU9265();
  Serial.print("加速度X[g]: "); Serial.println(AcX, 4);
  Serial.print("加速度Y[g]: "); Serial.println(AcY, 4);
  Serial.print("加速度Z[g]: "); Serial.println(AcZ, 4);

  Serial.print("ジャイロX[dps]: "); Serial.println(GyX, 4);
  Serial.print("ジャイロY[dps]: "); Serial.println(GyY, 4);
  Serial.print("ジャイロZ[dps]: "); Serial.println(GyZ, 4);

  // ---- LIS3MDL ----
  LIS.read();
  MagX = LIS.m.x + 1034.8;
  MagY = LIS.m.y - 1656;
  MagZ = LIS.m.z;

  mag_theta = ((atan2(MagY,MagX)) - PI) * -1;//追加部分

  Serial.print("磁気X: "); Serial.println(MagX);
  Serial.print("磁気Y: "); Serial.println(MagY);
  Serial.print("磁気Z: "); Serial.println(MagZ);
  Serial.print("houi =");Serial.println(mag_theta*(180/PI));//現在、期待が北から何度の方向を向いてるか

  double MagTheta = 0; 
  MagTheta = acos(((sin(mag_theta)*(6371*dlng))+(cos(mag_theta)*(6371*dlat)))/(6371 * sqrt(pow(dlat,2) + pow(dlng, 2))));
  MagTheta = MagTheta * (180/PI);

  Serial.print("θ=");
  Serial.println(theta);

  outer = (sin(mag_theta))*(6371*dlat) - (cos(mag_theta)*(6371*dlng));

   // ---- ここでサーボ制御処理を実行 ----
    //myservo・・・右　myservo2・・・左 デフォルトで左右とも°の位置
  
  if ((outer < 0) && (MagTheta > 0) && (MagTheta <= 60)) {
    if(distance < 30) {//近い時
      control_log = "110°:left";
      myservo.write(140);
      myservo2.write(110);
      //delay(100);
      myservo2.write(140);
      //delay(100);  
    } else {//遠い時
      control_log = "125°:left";
      myservo.write(140);
      myservo2.write(125);
      //delay(100);
      myservo2.write(140);
      //delay(100);
    }
  }
  else if ((outer > 0) && (MagTheta > 0) && (MagTheta <= 60)) {//反時計回りに旋回させるとき
    if(distance < 30) {//近い時
      control_log = "110°:right";
      myservo.write(110);
      myservo2.write(140);
      //delay(100);
      myservo.write(140);
      //delay(100);      
    } else {
      control_log = "125°:right";
      myservo.write(125);
      myservo2.write(140);
      //delay(100);
      myservo.write(140);
      //delay(100);
    }
    
  } else if ((outer < 0) && (MagTheta > 60) && (MagTheta <= 120)) {
    if(distance < 30) {//近い時
      control_log = "50°:left";
      myservo.write(140);
      myservo2.write(50);
      //delay(100);
      myservo2.write(140);
      //delay(100);
    } else {//遠い時
      control_log = "65°:left";
      myservo.write(140);
      myservo2.write(65);
     // delay(100);
      myservo2.write(140);
     // delay(100);      
    }
  }
  else if ((outer > 0) && (MagTheta > 60) && (MagTheta <= 120)) {
    if(distance < 30) {//近い時
      control_log = "50°:right";
      myservo.write(50);
      myservo2.write(140);
     // delay(100);
      myservo.write(140);
      //delay(100);      
    } else {
      control_log = "65°:rigth";
      myservo.write(65);
      myservo2.write(140);
      //delay(100);
      myservo.write(140);
      //delay(100);       
    }     
  }
  else if ((outer < 0) && (MagTheta > 120) && (MagTheta <= 180)) {
    if(distance < 30) {//近い時
      control_log = "10°時計回り:left";
      myservo.write(140);
      myservo2.write(10);

     // delay(100);
      myservo2.write(140);
      //delay(100);      
    } else {
      control_log = "30°時計回り:left";
      myservo.write(140);
      myservo2.write(30);
      //delay(100);
      myservo2.write(140);
      //delay(100);
    }       
  }
  else if ((outer > 0) && (MagTheta > 120) && (MagTheta <= 180)){
      if(distance < 30) {//近い時
      control_log = "10°反時計回り:rigth";
      myservo.write(10);
      myservo2.write(140);
      //delay(100);
      myservo.write(140);
     // delay(100);
    } else {
      control_log = "30°:rigth";
      myservo.write(30);
      myservo2.write(140);
     // delay(100);
      myservo.write(140);
     // delay(100);
    }
  }else if(theta == 0){myservo.write(140); myservo2.write(140);}
  // ---- 姿勢推定フィルタ更新 ----
  filter.update(GyX * DEG_TO_RAD, GyY * DEG_TO_RAD, GyZ * DEG_TO_RAD,
                AcX, AcY, AcZ,
                MagX, MagY, MagZ);

  roll  = filter.getRoll();
  pitch = filter.getPitch();
  yaw   = filter.getYaw();

  Serial.print("Roll: "); Serial.println(roll);
  Serial.print("Pitch: "); Serial.println(pitch);
  Serial.print("Yaw: "); Serial.println(yaw);

  Serial.println(control_log);

  Serial.println("ーーーーーーーーーーーーーーーーーーーー");

  //delay(100);
}